#!/usr/bin/env python3
#===- act/back_end/confignet_io.py - ConfigNet IO ---------------------====#
# ACT: Abstract Constraint Transformer
# Copyright (C) 2025– ACT Team
#
# Licensed under the GNU Affero General Public License v3.0 or later (AGPLv3+).
# Distributed without any warranty; see <http://www.gnu.org/licenses/>.
#===---------------------------------------------------------------------===#
#
# Purpose:
#   ConfigNet IO utilities.
#   - examples_config materialization helpers (generated entries + nets JSON)
#
#===---------------------------------------------------------------------===#

from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, Optional

import torch
import yaml

from act.back_end.serialization.serialization import NetSerializer

# Prefix for networks generated by Confignet when materializing into
# examples_config.yaml. Keeping it stable lets us cleanly wipe/refresh the
# generated entries on each run without touching hand-authored entries.
CONFIGNET_PREFIX = "cfg_seed"

# Default targets used by ModelFactory/validate_verifier
DEFAULT_EXAMPLES_CONFIG = "act/back_end/examples/examples_config.yaml"
DEFAULT_NETS_DIR = "act/back_end/examples/nets"

# NOTE: JSONL record helpers and run-id hashing were removed. Confignet
# now only materializes YAML entries and nets JSON.
# ---------------------------------------------------------------------------
# examples_config.yaml helpers (Confignet → examples_config)
# ---------------------------------------------------------------------------


def write_confignet_entries_to_examples_config(
    *,
    entries: Dict[str, Dict[str, Any]],
    config_path: str = DEFAULT_EXAMPLES_CONFIG,
) -> None:
    """
    Replace the generated Confignet entries inside examples_config.yaml.

    Strategy:
    - Load YAML as a dict
    - Remove old generated entries by prefix
    - Insert new generated entries under networks
    """
    if not entries:
        return
    if any(not name.startswith(CONFIGNET_PREFIX) for name in entries):
        bad = sorted(name for name in entries if not name.startswith(CONFIGNET_PREFIX))
        raise ValueError(f"Confignet entries must start with '{CONFIGNET_PREFIX}': {bad}")

    path = Path(config_path)
    data = load_examples_config(str(path))
    networks = data.get("networks")
    if networks is None:
        networks = {}
        data["networks"] = networks
    if not isinstance(networks, dict):
        raise ValueError("examples_config.yaml 'networks' must be a mapping")

    for name in list(networks.keys()):
        if name.startswith(CONFIGNET_PREFIX):
            networks.pop(name)

    collisions = [name for name in entries if name in networks]
    if collisions:
        raise ValueError(f"Confignet entry names collide with existing networks: {collisions}")

    networks.update(entries)
    path.write_text(yaml.safe_dump(data, sort_keys=False), encoding="utf-8")


def load_examples_config(path: str = DEFAULT_EXAMPLES_CONFIG) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {}


def append_nets_json(
    *,
    nets: Dict[str, Any],
    nets_dir: str = DEFAULT_NETS_DIR,
) -> None:
    """Write ACT Net JSON files for generated entries (names must match)."""
    out_dir = Path(nets_dir)
    out_dir.mkdir(parents=True, exist_ok=True)
    for name, net in nets.items():
        path = out_dir / f"{name}.json"
        payload = _sanitize_payload_for_disk(NetSerializer.serialize_net(net))
        sanitized = _to_basic(payload)
        path.write_text(json.dumps(sanitized, ensure_ascii=True, indent=2), encoding="utf-8")


# ---------------------------------------------------------------------------
# Conversion helpers: ACT Net -> examples_config.yaml entry
# ---------------------------------------------------------------------------


def _to_basic(obj: Any) -> Any:
    """Convert tensors/Enums to JSON-serializable primitives."""
    if obj is None or isinstance(obj, (bool, int, float, str)):
        return obj
    if isinstance(obj, (list, tuple)):
        return [_to_basic(x) for x in obj]
    if isinstance(obj, dict):
        return {str(k): _to_basic(v) for k, v in obj.items()}
    if isinstance(obj, torch.Tensor):
        t = obj.detach().cpu()
        if t.numel() == 1:
            return float(t.item())
        return t.tolist()
    if hasattr(obj, "value"):
        return getattr(obj, "value")
    return str(obj)


def _sanitize_payload_for_disk(payload: Dict[str, Any]) -> Dict[str, Any]:
    """Drop non-serializable or oversized fields before writing nets JSON."""
    act_net = payload.get("act_net")
    if not isinstance(act_net, dict):
        return payload
    for layer in act_net.get("layers", []):
        if layer.get("kind") == "INPUT":
            params = layer.get("params", {})
            params.pop("labeled_input", None)
    return payload


def act_net_to_examples_entry(
    instance: Any,
    act_net: Any,
    *,
    description: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Convert an ACT Net into an examples_config.yaml network entry.
    """
    def _sanitize_params(kind: str, params: Dict[str, Any]) -> Dict[str, Any]:
        if not params:
            return {}
        if kind == "ASSERT":
            return _to_basic(params)
        cleaned: Dict[str, Any] = {}
        drop_tensor_keys = {
            "W",
            "b",
            "weight",
            "bias",
            "weights",
            "biases",
        }
        for key, val in params.items():
            if torch.is_tensor(val) and key in drop_tensor_keys:
                continue
            cleaned[key] = _to_basic(val)
        return cleaned

    layers_spec: List[Dict[str, Any]] = []
    for layer in getattr(act_net, "layers", []):
        raw_kind = getattr(layer, "kind", "")
        kind = raw_kind.value if hasattr(raw_kind, "value") else str(raw_kind)
        params = _sanitize_params(kind, getattr(layer, "params", {}))
        layers_spec.append(
            {
                "kind": kind,
                "params": params,
                "meta": _to_basic(getattr(layer, "meta", {})),
            }
        )

    arch = getattr(instance.family, "value", getattr(instance, "family", "unknown"))
    if arch == "cnn2d":
        arch = "cnn"

    return {
        "description": description or f"Generated by Confignet ({instance.instance_id})",
        "architecture_type": arch,
        "input_shape": list(instance.model_cfg.input_shape),
        "layers": layers_spec,
    }